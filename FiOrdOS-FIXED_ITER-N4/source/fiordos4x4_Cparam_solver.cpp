/**
 * This file is generated by FiOrdOs, a program licensed under GPL
 * by copyright holder Automatic Control Laboratory, ETH Zurich.
 * 
 * If you are interested in using this file commercially,
 * please contact the copyright holder.
 */

#include "fiordos4x4_Cparam_solver.h"
#include <stdio.h>
#include <math.h>
#include <string.h>

#ifdef MATLAB_MEX_FILE
#include "mex.h"
#endif

/* <<< print >>> */
static void printArray(realtype *arr, int dim) {
  int i;
  printf("[\n"); ;
  for (i=0; i<dim; i++) {
    printf("%8.16e\n",*arr++);
  }
  printf("]\n\n");
}

static void printArrayNamed(realtype *arr, int dim, char *txt) {
  printf("%s = ",txt);
  printArray(arr,dim);
}

/* <<< copy vectors >>> */
static void copyvec4(realtype *dest, const realtype *src) {
    {
        int i;
        for (i=0; i<4; ++i) {
            dest[i] = src[i];
        }
    }
}
static void copyvec24(realtype *dest, const realtype *src) {
    {
        int i;
        for (i=0; i<24; ++i) {
            dest[i] = src[i];
        }
    }
}

/* <<< projection >>> */
static void algoOuter_project(realtype *thevec, fiordos4x4_Cparam_Work *work, fiordos4x4_Cparam_Params *params) {
    realtype *theveci;

    /* ====== EssRnplus L1 ====== */
    theveci = thevec;
    /* ------ projection ------ */
    {
        int icoord;
        for (icoord=0; icoord<24; ++icoord) {
          if (theveci[icoord]<0) {
            theveci[icoord] = 0;
          }
        }
    }
}

/* <<< oracle >>> */
static void algoInner_oracle(fiordos4x4_Cparam_Work *work, fiordos4x4_Cparam_Params *params, realtype *z, realtype *fval, realtype *grad) {
    realtype hz[4];
    {
        /* (hz):= (params->H)^T*(z);   // (4x4)*(4x1) */
        int i,k;
        realtype tmp;
        for (i=0; i<4; ++i) {
            tmp = 0.0;
            for (k=0; k<4; ++k) {
              tmp += params->H[k+i*4]*z[k];
            }
            hz[i] = tmp;
        }
    }

    if (NULL!=fval) {
        int i;
        realtype tmp;
        tmp = 0.0;
        for (i=0; i<4; ++i) {
          tmp += (0.5*hz[i] + work->Prob.inner_g[i]) * z[i];
        }
        fval[0] = tmp + work->Prob.inner_c[0];
    }

    if (NULL!=grad) {
        int i;
        for (i=0; i<4; ++i) {
          grad[i] = hz[i] + work->Prob.inner_g[i];
        }
    }
}
static void algoOuter_oracle(fiordos4x4_Cparam_Work *work, fiordos4x4_Cparam_Params *params, realtype *v, realtype *fval, realtype *grad, fiordos4x4_Cparam_Settings *settings) {
    realtype *vineq;
    realtype *gradineq;
    vineq = v+0;
    gradineq = grad+0;

    /* << data of inner problem >> */
    {
        /* (work->Prob.inner_g):= (params->Ai)^T*(vineq)+(params->g);   // (4x24)*(24x1),(4x1) */
        int i,k;
        realtype tmp;
        for (i=0; i<4; ++i) {
            tmp = 0.0;
            for (k=0; k<24; ++k) {
              tmp += params->Ai[k+i*24]*vineq[k];
            }
            work->Prob.inner_g[i] = tmp + params->g[i];
        }
    }
    {
        /* (work->Prob.inner_c):= -(vineq)^T*(params->bi);   // (1x24)*(24x1) */
        int k;
        realtype tmp;
            tmp = 0.0;
            for (k=0; k<24; ++k) {
              tmp -= vineq[k]*params->bi[k];
            }
            work->Prob.inner_c[0] = tmp;
    }

    /* << inner algorithm >> */
    /* AlgoFgmA */
    {
        work->algoInner.res_stopcode = 0;
        {
            realtype z[4];
            realtype zp[4];
            realtype y[4];
            realtype grady[4];
            int iter;
            int icoord;
            realtype alpha,alpha_p;
            realtype beta;
            realtype btrhs;
            realtype deltai;
            realtype fzp[1],fy[1];
            realtype tstep;
            int btnum;
            realtype gradzp[4];
            realtype btlhs2,btrhs2;
            int restarted;
            realtype rscond;
            
            iter =0;
            
            copyvec4(z,work->algoInner.init);  /* (z):=(work->algoInner.init) */
            copyvec4(y,z);  /* (y):=(z) */
            alpha = 1;
            copyvec4(zp,z);  /* (zp):=(z) */
            tstep = work->algoInner.tstep;
            btnum = work->algoInner.btnum;
            
            while (iter<settings->algoInner.maxit) {
                ++iter;
            
                restarted = 0;
                while (1) {  /* restarting-loop */
                    if (1==work->algoInner.btstopped) {
                        algoInner_oracle(work,params,y,NULL,grady);
                    } else {
                        algoInner_oracle(work,params,y,fy,grady);
                    }
                    while (1) {  /* backtracking-loop */
                        for (icoord=0; icoord<4; ++icoord) {
                            zp[icoord] = y[icoord] - tstep*grady[icoord];
                        }
                        if (1==work->algoInner.btstopped) { break; }
                        if (btnum>=100) {
                            work->algoInner.btstopped=1;
                            break;
                        }
                        algoInner_oracle(work,params,zp,fzp,gradzp);
                        btrhs = fy[0];
                        btrhs2=0; btlhs2=0;
                        for (icoord=0; icoord<4; ++icoord) {
                            deltai  = zp[icoord] - y[icoord];
                            btrhs  += grady[icoord]*deltai;
                            btlhs2 += deltai*(gradzp[icoord]-grady[icoord]);
                            btrhs2 += deltai*deltai;
                        }
                        btrhs2 *= 1.0/(2*tstep);
                        btrhs += btrhs2;
                        if (btlhs2<0) {btlhs2=-btlhs2;}
                        if (fzp[0]<=btrhs+1.000000e-14 || btlhs2<=btrhs2+1.000000e-14) {
                            break;
                        } else {
                            tstep = tstep * 0.5;
                            if (tstep<=work->algoInner.tstepmin) {
                                tstep = work->algoInner.tstepmin;
                                work->algoInner.btstopped = 1;
                            }
                            ++btnum;
                        }
                    }
            
                    if (1==restarted) { break; }
                    rscond = 0;
                    for (icoord=0; icoord<4; ++icoord) {
                        rscond += (y[icoord] - zp[icoord])*(zp[icoord] - z[icoord]);
                    }
                    if ( rscond > 1e-14) {
                        alpha = 1;
                        copyvec4(y,z);  /* (y):=(z) */
                        restarted = 1;
                    } else {
                        break;
                    }
                }
            
            
                alpha_p= 0.5*alpha*(sqrt(alpha*alpha+4)-alpha);
                beta = alpha*(1-alpha)/(alpha*alpha+alpha_p);
                for (icoord=0; icoord<4; ++icoord) {
                    y[icoord] = zp[icoord] + beta*(zp[icoord]-z[icoord]);
                }
            
                copyvec4(z,zp);  /* (z):=(zp) */
                alpha = alpha_p;
            }
            copyvec4(work->algoInner.res_z,zp);  /* (work->algoInner.res_z):=(zp) */
            work->algoInner.res_iter = iter;
            work->algoInner.tstep = tstep;
            work->algoInner.btnum = btnum;
        }
    }

    /* << outer gradient >> */
    if (NULL!=grad) {
        {
            /* (gradineq):= (params->Ai)*(work->algoInner.res_z)-(params->bi);   // (24x4)*(4x1),(24x1) */
            int i,k;
            realtype tmp;
            for (i=0; i<24; ++i) {
                tmp = 0.0;
                for (k=0; k<4; ++k) {
                  tmp += params->Ai[i+k*24]*work->algoInner.res_z[k];
                }
                gradineq[i] = tmp - params->bi[i];
            }
        }
    }

    /* << dual function value >> */
    if (NULL!=fval) {
        algoInner_oracle(work,params,work->algoInner.res_z,fval,NULL);
    }

}

/* <<< SOLVE >>> */
void fiordos4x4_Cparam_solve(fiordos4x4_Cparam_Params *params, fiordos4x4_Cparam_Settings *settings, fiordos4x4_Cparam_Result *result, fiordos4x4_Cparam_Work *work) {

    /* << prepare data >> */
    {
        /* --- calc traceH0 --- */
        {
            realtype tr;
            int i;
            tr = 0;
            for (i=0;i<16;i+=5) {
                tr += params->H[i];
            }
            if (tr<=0) {
                result->exitflag = -1;
                return;
            }
            work->Prob.traceH0[0] = tr;
        }
        
        /* === compute global characteristics === */
        {
            realtype tr;
            realtype norm1;
            int i;
            realtype norm1col, elem;
            int icol,irow;
            norm1=0;
            i=0;
            for (icol=0;icol<4;++icol) {
                norm1col=0;
                for(irow=0;irow<4;++irow) {
                    elem = params->H[i];
                    if (elem>0) {
                        norm1col+=elem;
                    } else {
                        norm1col-=elem;
                    }
                    ++i;
                }
                if (norm1col>norm1) {norm1=norm1col;}
            }
            tr = work->Prob.traceH0[0];
            work->algoInner.glob_LbL = 1.0/4*tr;
            work->algoInner.glob_UbL = tr;
            if (norm1<tr) {work->algoInner.glob_UbL = norm1;}
        }
        {
            int i;
            realtype amaxnorm, absai;
            amaxnorm = 0.0;
            for(i=0;i<96;++i) {
                absai = params->Ai[i];
                if (absai<0) {absai=-absai;}
                if (absai > amaxnorm) {amaxnorm=absai;}
            }
            if (amaxnorm<=0) {
                result->exitflag = -1;
                return;
            }
            work->algoOuter.glob_LbL = amaxnorm*amaxnorm/work->Prob.traceH0[0];
        }
        {
            work->algoOuter.glob_UbL = HUGE_VAL;
        }
        
        /* === initial points === */
        copyvec4(work->algoInner.init,settings->algoInner.init);  /* (work->algoInner.init):=(settings->algoInner.init) */
        copyvec24(work->algoOuter.init,settings->algoOuter.init);  /* (work->algoOuter.init):=(settings->algoOuter.init) */
        algoOuter_project(work->algoOuter.init,work,params);
        
    }

    {
        realtype tstepmin;
        work->algoInner.tstep = 1.0/work->algoInner.glob_LbL;
        work->algoInner.btnum = 0;
        tstepmin = 1.0/work->algoInner.glob_UbL;
        if (tstepmin < 1e-14) {tstepmin=1e-14;}
        work->algoInner.tstepmin = tstepmin;
        work->algoInner.btstopped = 0;
    }
    {
        realtype tstepmin;
        work->algoOuter.tstep = 1.0/work->algoOuter.glob_LbL;
        work->algoOuter.btnum = 0;
        tstepmin = 1.0/work->algoOuter.glob_UbL;
        if (tstepmin < 1e-14) {tstepmin=1e-14;}
        work->algoOuter.tstepmin = tstepmin;
        work->algoOuter.btstopped = 0;
    }
    
    /* << main algorithm >> */
    /* AlgoFgmA */
    {
        work->algoOuter.res_stopcode = 0;
        {
            realtype z[24];
            realtype zp[24];
            realtype y[24];
            realtype grady[24];
            int iter;
            int icoord;
            realtype alpha,alpha_p;
            realtype beta;
            realtype btrhs;
            realtype deltai;
            realtype fzp[1],fy[1];
            realtype tstep;
            int btnum;
            realtype gradzp[24];
            realtype btlhs2,btrhs2;
            int restarted;
            realtype rscond;
            
            iter =0;
            
            copyvec24(z,work->algoOuter.init);  /* (z):=(work->algoOuter.init) */
            copyvec24(y,z);  /* (y):=(z) */
            alpha = 1;
            copyvec24(zp,z);  /* (zp):=(z) */
            tstep = work->algoOuter.tstep;
            btnum = work->algoOuter.btnum;
            
            while (iter<settings->algoOuter.maxit) {
                ++iter;
            
                restarted = 0;
                while (1) {  /* restarting-loop */
                    if (1==work->algoOuter.btstopped) {
                        algoOuter_oracle(work,params,y,NULL,grady,settings);
                    } else {
                        algoOuter_oracle(work,params,y,fy,grady,settings);
                    }
                    if ( 1==settings->approach.warmstartInner) {  /* reinit inner */
                        copyvec4(work->algoInner.init,work->algoInner.res_z);  /* (work->algoInner.init):=(work->algoInner.res_z) */
                    }
                    while (1) {  /* backtracking-loop */
                        for (icoord=0; icoord<24; ++icoord) {
                            zp[icoord] = y[icoord] + tstep*grady[icoord];
                        }
                        algoOuter_project(zp,work,params);
                        if (1==work->algoOuter.btstopped) { break; }
                        if (btnum>=100) {
                            work->algoOuter.btstopped=1;
                            break;
                        }
                        algoOuter_oracle(work,params,zp,fzp,gradzp,settings);
                        btrhs = fy[0];
                        btrhs2=0; btlhs2=0;
                        for (icoord=0; icoord<24; ++icoord) {
                            deltai  = zp[icoord] - y[icoord];
                            btrhs  += grady[icoord]*deltai;
                            btlhs2 += deltai*(gradzp[icoord]-grady[icoord]);
                            btrhs2 += deltai*deltai;
                        }
                        btrhs2 *= 1.0/(2*tstep);
                        btrhs -= btrhs2;
                        if (btlhs2<0) {btlhs2=-btlhs2;}
                        if (fzp[0]>=btrhs-1.000000e-14 || btlhs2<=btrhs2+1.000000e-14) {
                            break;
                        } else {
                            tstep = tstep * 0.5;
                            if (tstep<=work->algoOuter.tstepmin) {
                                tstep = work->algoOuter.tstepmin;
                                work->algoOuter.btstopped = 1;
                            }
                            ++btnum;
                        }
                    }
            
                    if (1==restarted) { break; }
                    rscond = 0;
                    for (icoord=0; icoord<24; ++icoord) {
                        rscond += (y[icoord] - zp[icoord])*(zp[icoord] - z[icoord]);
                    }
                    if ( rscond > 1e-14) {
                        alpha = 1;
                        copyvec24(y,z);  /* (y):=(z) */
                        restarted = 1;
                    } else {
                        break;
                    }
                }
            
            
                alpha_p= 0.5*alpha*(sqrt(alpha*alpha+4)-alpha);
                beta = alpha*(1-alpha)/(alpha*alpha+alpha_p);
                for (icoord=0; icoord<24; ++icoord) {
                    y[icoord] = zp[icoord] + beta*(zp[icoord]-z[icoord]);
                }
            
                copyvec24(z,zp);  /* (z):=(zp) */
                alpha = alpha_p;
            }
            copyvec24(work->algoOuter.res_z,zp);  /* (work->algoOuter.res_z):=(zp) */
            work->algoOuter.res_iter = iter;
            work->algoOuter.tstep = tstep;
            work->algoOuter.btnum = btnum;
        }
    }
    
    
    /* << finalize result >> */
    copyvec24(result->la,work->algoOuter.res_z);  /* (result->la):=(work->algoOuter.res_z) */
    algoOuter_oracle(work,params,work->algoOuter.res_z,&(result->d),NULL,settings);
    copyvec4(result->x,work->algoInner.res_z);  /* (result->x):=(work->algoInner.res_z) */
    result->iter = work->algoOuter.res_iter;
    result->exitflag = work->algoOuter.res_stopcode;

}



/* <<< INIT >>> */
void fiordos4x4_Cparam_init(fiordos4x4_Cparam_Params *params, fiordos4x4_Cparam_Settings *settings, fiordos4x4_Cparam_Result *result, fiordos4x4_Cparam_Work *work) {
settings->approach.warmstartInner = 1;
{int i; for (i=0;i<4;++i) {settings->algoInner.init[i] = (realtype) 0.0;}}
settings->algoInner.maxit = 100;
{int i; for (i=0;i<24;++i) {settings->algoOuter.init[i] = (realtype) 0.0;}}
settings->algoOuter.maxit = 100;
}

